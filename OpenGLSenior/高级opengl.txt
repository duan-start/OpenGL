》》》深度测试：
通过给定的glEnable(GL_DEPTH_TEST);
和glDepthFunc（。。。）。控制深度缓冲的类型

观察空间的z值可能是投影平截头体的近平面(Near)和远平面(Far)之间的任何值。我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间，其中的一种方式就是将它们线性变换到[0, 1]范围之间。下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值：

Fdepth=（z−near）/（far−near）no

Fdepth=（1/z−1/near1）/（far−1/near）
虽然但是，这种虽然看是合理的方法是不行的，
毕竟我们要求在近距离要求高精度，在远距离要求低精度。
深度缓冲中0.5的值并不代表着物体的z值是位于平截头体的中间了，这个顶点的z值实际上非常接近近平面

片段的深度值会随着距离迅速增加，所以几乎所有的顶点的深度值都是接近于1.0的。


>>>深度冲突
主要是因为精度不够导致的一些临近的片段（像素）的判断会反复跳转
箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）

物体不要放一起太近，更高位数的存储还有就是近平面放远点（实际上是近平面靠近（加强精度）放在一起的物体）


》》》模板测试
模板测试和模板缓冲是在深度之前进行的（glfw会自动构建这个模板库）

。通过在渲染时修改模板缓冲的内容，我们写入了模板缓冲。在同一个（或者接下来的）帧中，我们可以读取这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：

启用模板缓冲的写入。
渲染物体，更新模板缓冲的内容。
禁用模板缓冲的写入。
渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。

模板缓冲
与屏幕相关：虽然模板缓冲区存储的值可以看作是与计算机屏幕上的像素相对应的，但这些像素是通过相机视角观察三维空间中的对象而得到的。每个像素的具体值反映了该位置上渲染对象的状态。

三维场景的映射：当你渲染三维对象时，你会使用模型视图投影矩阵将三维坐标变换到裁剪空间，再映射到屏幕坐标。模板缓冲中的每个位置对应于最终屏幕上的某个像素，从而与三维场景中的几何体相关。

总之：
模板缓冲是在深度测试之前的，是对相应的三维空间投射到二维空间的一个收集，我们可以通过更改这个缓冲里面的数据和深度测试。实现自定义的遮挡。、
就比如下面的这个逻辑。原先三维在二维的整个图面上的值都设置为了1，后面将其中的某个物体放大，那么叠加起来的地方在观察者看的地方就是2。这样就可以控制不同的生成（是否绘制）


实操：
先开启模板缓冲和写入。
正常绘制整个场景。
关闭模板缓冲的写入。（保证只有第一个场景下的物体的面向屏幕的缓冲值是 1）
禁用深度测试。（防止遮挡第二次绘制的图）
重新绘制一个偏大的图（通过model）,
glenable(gl_stenctil test)
glclear()
glstencilmask()设置掩码
glstencifunc()设置是否丢弃的原则
glstencilop () 设置丢弃或不丢弃对模板缓冲的写入

》》》混合
alpha 决定的是遮挡的光的程度。也可以理解为当前材质的贡献值
即0表示完全透明，1表示完全不透明

草：
将一个2d的纹理贴图到一个2d四边形上，然后只显示草的纹理，忽略剩下的部分
丢弃纹理中的透明部分
加载一个透明的纹理，就是在创建纹理的时候去传入四个分量（此时如果用取样去取样是也个vec4 的类型，不需要我们再加上什么）

正常贴图和创建，我们必然得到的是什么都显示的一个纹理图
（Opengl不知道如何根据alpha 去丢去片段）

在pixel shader 里面 对texColor.a进行判断，利用discard关键字进行是否丢弃的判断

//注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：//因为绘制的图比纹理的图要大

为了实现混合，启用GL BLEND
glblendfunc ,设置源和目标因子，实际上就是他们的权重

由于从前往后绘制会有深度测试，产生遮挡。
所以我们对于透明的物体采用，从后向前绘制。遮挡也是有的，但是会不断的blend。如果从前往后，第一个物体和后面的混合，然后再绘制第二个物体（此时已经判断并遮挡了）

》》》面剔除
我们根本看不见那么多面
通过面的绘制顺序，控制前面和后面的面的绘制顺序。然后通过glEnable(GL_CULL_FACE);
glCullFace(GL_BACK);
glFrontFace(GL_CW);
就可以指定绘画对应的面了。

》》》帧缓冲
创建和绑定帧缓冲（缓冲类型）

一个完整的帧缓冲需要满足以下的条件：
附加至少一个缓冲（颜色、深度或模板缓冲）。
至少有一个颜色附件(Attachment)。
所有的附件都必须是完整的（保留了内存）。
每个缓冲都应该有相同的样本数(sample)。

设置自己的帧缓冲和默认的帧缓冲是不一样的，为了以后还能接收到默认视口的渲染，我们需要结束后绑定默认的帧缓冲。

帧缓冲的附件：
一个内存位置
所有的渲染结构都会存储再一个纹理图像中
先创建一个普通纹理（但是没有用具体的数据填充他）
如果想将屏幕渲染到一个更大或是更小的纹理上，你需要再渲染到帧缓冲前，重新设置glviewport(渲染窗口的大小)

将纹理附加到帧缓冲上
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);
除了颜色附件，我们还可以附加一个深度和模板对象的纹理到缓冲对象中。
GL_DEPTH_ATTACHMENT

创建一个渲染对象
我们将它的内部格式设置为GL_DEPTH24_STENCIL8，对我们来说这个精度已经足够了
分配内存之后（绑定就是为了这个作用），解绑这个缓冲对象

将该缓冲对象附加到帧缓冲的深度和模板附件上
检查帧缓冲是否完整

//
帧缓冲（Frame Buffer）和其附件（Attachments）的初始化和用途。让我们来详细解释一下帧缓冲中绑定的各种缓冲是如何初始化的，以及它们的作用。

---

### 1. **帧缓冲（Frame Buffer）和附件（Attachments）**
帧缓冲是一个用于存储渲染目标的集合，它包含多个附件，每个附件可以存储不同类型的数据（如颜色、深度、模板等）。这些附件通常包括：
- **颜色附件（Color Attachments）**：用于存储颜色数据。
- **深度附件（Depth Attachment）**：用于存储深度信息。
- **模板附件（Stencil Attachment）**：用于存储模板信息。

---

### 2. **帧缓冲附件的初始化**
当你创建一个帧缓冲时，它的附件（如颜色缓冲、深度缓冲等）并不会自动初始化为“有用”的数据。这些附件需要手动绑定并初始化，具体步骤如下：

#### （1）创建帧缓冲对象（FBO）
```c++
GLuint framebuffer;
glGenFramebuffers(1, &framebuffer);
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
```

#### （2）创建并绑定附件
- **颜色附件**：通常是一个纹理（Texture）或渲染缓冲对象（Render Buffer Object，RBO）。
- **深度附件**：通常是一个RBO。
- **模板附件**：通常是一个RBO。

例如，创建一个颜色纹理附件：
```c++
GLuint colorTexture;
glGenTextures(1, &colorTexture);
glBindTexture(GL_TEXTURE_2D, colorTexture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorTexture, 0);
```

创建一个深度RBO附件：
```c++
GLuint depthRBO;
glGenRenderbuffers(1, &depthRBO);
glBindRenderbuffer(GL_RENDERBUFFER, depthRBO);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRBO);
```

#### （3）检查帧缓冲是否完整
```c++
if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
{
    std::cerr << "Framebuffer not complete!" << std::endl;
}
```

---

### 3. **帧缓冲附件的内容**
在创建和绑定附件后，这些附件的内容是**未初始化的**（或者说，是“空的”）。它们需要通过渲染操作来填充数据。具体来说：
- **颜色附件**：在渲染过程中，片段着色器（Fragment Shader）的输出会被写入颜色附件。
- **深度附件**：深度值会在深度测试过程中自动生成并写入深度附件。
- **模板附件**：模板值会在模板测试过程中自动生成并写入模板附件。

---

### 4. **帧缓冲附件的作用**
帧缓冲的附件并不是“自动生成给外面用的”，而是需要通过以下方式使用：
- **渲染到帧缓冲**：在绑定帧缓冲后，所有渲染操作的结果会被写入帧缓冲的附件中，而不是默认帧缓冲（屏幕）。
- **从帧缓冲读取数据**：可以通过纹理采样（如果附件是纹理）或读取像素数据（`glReadPixels`）等方式从帧缓冲中获取数据。

例如，如果你将一个纹理绑定到帧缓冲的颜色附件，那么渲染操作的结果会被写入这个纹理。你可以将这个纹理用于后续的渲染操作（如后处理、阴影映射等）。

---

### 5. **总结**
- **帧缓冲的附件在创建时是空的**，需要通过渲染操作来填充数据。
- 这些附件的内容并不是“自动生成的”，而是需要通过渲染过程来生成。
- 它们的作用是**存储渲染结果**，以便后续使用（如后处理、阴影映射、纹理采样等）。

//

c_str() 是 C++ 中 std::string 类的一个成员函数，用于将 std::string 对象转换为 C 风格的字符串（以空字符 \0 结尾的字符数组）。它的返回值是一个指向字符串首字符的常量指针 const char*。


