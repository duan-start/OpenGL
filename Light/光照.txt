》》》颜色
glsl和c++有点不太一样？
(正常的点乘dot就好了，如果是叉乘的话就要用到glm::cross函数)
使用一个vec4表示有透明通道的颜色
vec3* vec3也是vec3 类型的
物体吸收的颜色vec3

创建一个表示灯源的立方体（因为我们需要一个物体来表示光源在3d场景中的位置），为这个灯创建一个专门的vao
其他的都差不多
只需要绑定VBO不用再次设置VBO的数据，因为箱子的VBO数据中已经包含了正确的立方体顶点数据
设置顶点属性
启用对应的顶点属性

我们不希望灯的颜色在接下来的教程中因光照计算的结果而受到影响，而是希望它能够与其它的计算分离。我们希望灯一直保持明亮，不受其它颜色变化的影响（这样它才更像是一个真实的光源）。

实操：
就是专门设置一个立方体光源（同样是那几种顶点变换），然后关于实际物体的颜色，实操上改为环境光和物体本身反射的光（即不吸收的rgb）的相乘

》》》基础光照/材质
环境光照
永远给物体一些颜色

漫反射光照
物体的某一部分越是正对着光照，物体的某一部分越是正对着光源，它就会越亮

镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色

像素着色器：
环境光*物体反射的属性

存储一个表面的法向量（角度越小，距离越近，能量越强）

法向量：
法向量是一个垂直于顶点表面的（单位）向量。由于顶点本身并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。
也就是说我们会存储点的法向量，对于面的法向量，我们会通过插值计算的方式计算得出，不需要额外存储（硬朗的表面的顶点可能有多个法向量）

如果说我们对模型进行了不等比的缩放，我们对他对应的法向量也需要进行修复（model的逆inverse的装置（transpose）），但是，如果是等比的话实际上就没有什么关系，如果是旋转的话，我们也要进行相应的旋转

我们将环境光照和直接光照的能量加起来，然后直接×上对应的物体的光照，最终就能实现了。

实操：
对于这种着色器模型，布林冯的着色模型，抽象来讲就是环境光照和漫反射和高光。
具体在着色语言中，在片段着色器中，创建两个结构体（一个是光照的强度,包括环境光ambient（这个值一般设的比较小），diff漫反射的光照强度，第三个就是高光）
对于物体的材质，我们同样创建一个结构体，包括在不同的光照下的材质。
具体的计算方式：
环境光*环境光反射的材质；
至于漫反射的能量的强度，我们需要存储法向向量，光照位置，物体位置。进行归一化，从而得出光线和法线的点乘的大小，而这个计算得出的float 就是我们diff接受的能量（每个像素）
高光：
我们需要摄像机的位置（观测的位置），光源的位置，法向的位置，判断光源反射（reflectDir是两个满足物理关系的）和视线两个向量（同时通过Pow函数加大这个区分度）。最后计算出的这个float 就是这个高光能量的接受量。

最后的fragcolor就是所有的能量加在一起。


》》》光照贴图
漫反射贴图：
将之前的漫反射的颜色向量改为漫反射贴图
sampler2D就是所谓的不透明类型（不能实例化，只能写成uniform）（在cpu源码中写成setInt）
我们也移除了环境光材质颜色向量，因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以我们不需要将它们分开储存

》》》投光物
Light 结构体里面的数据改变了
将以前存储的定向位置改为光照方向
物体的指向光源的方向就是-light.direction
方向向量和位置向量都可以用vec3 来表示（毕竟是前期计算），但是一旦涉及到变换和投影，第四个分量（方向是0，表示无穷远。位置是1，表示point）
通过检测光照的第四个分量，我们可以比较清楚的确定到底是方向还是位置

》》》手电筒的光照
一种聚光的类型：
一个世界的空间位置，一个方向，一个cutoff angle,
lightPos,lightDir,SpotDir,Phi(是指半个角)，Theta()

创建一个平滑的过度：
除了已有的一个内圆锥，我们还需要创建一个外圆锥（用来向黑暗过渡的）
I=（θ−γ）/ϵ

这里ϵ(Epsilon)是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。
最终的I值就是在当前片段聚光的强度

总而言之就是三个角，分别是内切光角，外切光角。还有一个设置在这两个之间的theta角（看起来像是具体的fragpos和lightdirection的夹角，会影响插值）。根据这三个角的余弦值，我们能够平滑的设置各种插值

》》有一个错误就是我们每次传输顶点着色器的位置数据时（我们要传输有model 改变过的数据，保证后面灯光检测的正确性）
