.Log  
#一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码

 在学习计算机图形学的过程中，对opengl 有了更加深入的理解，为此，专门重新记录感想和opengl 里面的知识
  
   glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);这个是opengl 专门给我们定义好的回调函数模板，在创建回调的时候，我们自己创建的具体函数将传递给这个函数（在opengl里面已经被定义好的），glpollevents 在每次窗口改变的时候都会查找相应的回调函数进行更改

  #图形渲染管线（graphics pipeline） 将3d的坐标转化为2d坐标，再将2d的坐标转化为有颜色的实际像素，。每一个阶段都有自己确定的函数，会在这一个阶段执行自己特定的函数，每一个阶段的小程序（gpu并行执行），成为shader.
   在opengl 中只允许我们编写顶点shader ，片段（fragment）shader (pixel shader 针对每个像素的操作) 。
   
   顶点数据和顶点属性 vertex data ， vertex attribute(顶点的属性，包含一系列的顶点的性质，位置，颜色，甚至可能还有法线的信息？)。
   需要为opengl 指定数据表示的渲染类型（线，面，三角形） 图元
   GL_POINTS.GL TRIANGLES,GL_LINE_SKIP

   顶点着色器（处理顶点属性，将位置3d坐标转化为另一种坐标形式）
   几何着色器（输入顶点，将顶点形成图元）
   图元装配（输入顶点，装配为指定图元）
   光栅化阶段（将图元映射为最终的屏幕上的像素（反走样））主要应该是采样（并且执行裁切，将视图之外的像素丢弃），
   片段着色器（pixel 像素操作） 计算一个像素的最终颜色（）
   alpha 和混合阶段（）检测片段对应的深度，判断前后位置（此时按理是由两个图像，一个是深度缓存图像，一个是最终的图像）。丢弃后面被遮盖的。检测alpha 值，并对物体进行混合。

    #实操：
    opengl 的可见区域，标准立方体内部。opengl 内部处理的坐标和通常的屏幕坐标是不一样的（主要是有一些创建窗口是把左上角当作0，0）glViewport是视口变换
    在创建一个opengl 里面三角形，首先去确定三角形的位置坐标（三维的）

   什么是顶点缓冲对象：vertex buffer objects
   在显存中存储大量顶点，使用者这种缓冲对象以便将所有的数据一次性发送到显卡上，
   顶点缓冲对象的类型 GL_ARRAY BUFFER
   
  步骤，创建顶点缓冲对象，将该缓冲对象绑定到opengl 的缓冲中(opengl 允许我们绑定多个不同的缓冲对象)  ，调用glbufferdata 函数将之前定义的顶点数据复制到缓冲的内存池上，
   


   
 一个非常简单的shader
    在顶点着色器中声明所有输入的顶点的属性，包括输入的向量，还有positon
    gl_Position 是一个已经预定义好的vec4类型的参数，会自动输出和做处理

   同样通过创建一个shader，用int 类型来接受他的标号
   通过glshadersource 将做着色器源码附加到着色器的对象中
   glcompileshader实现着色器的编译

  glgetshaderiv  检查编译是否成功，通过传递一个int 类型的指针，
  glgetshaderinfolog 获取失败的信息

 片段着色器（像素的着色器）
  输出具体的颜色FragColor ,这个是我们自己定义的颜色输出

 创建一个着色器的程序
  同样利用一个int 来接受创建的一个着色器程序对象，让后通过glattachshader 将不同的着色器附加到这个程序上，左后再通过gllinkprogram 函数进行链接
  
 glgetprogamiv()
   获取链接失败的函数
    
 通过gluseprogram函数来激活这个函数

 在着色器对象链接到程序对象后，删除着色器对象

 通过glvertexarrtribpointer告诉OpenGL如何解析顶点上的数据
 传递好顶点属性之后，我们需要glenabelvertexattibarray 打开（顶点属性位置值作为参数），
    
 顶点数组对象vao
 相当于是不同状态的存储
 具体存储方式表现为先绑定vao，在这个状态下绑定vbo ,传输数据，并配置顶点属性，同时打开相应glenablevertexattribarray, 

通过激活对应的着色器，绑定对应的vao 。最后通过gldrawarrays(),绘制的图元，顶点数组的起始索引，以及顶点个数
    
元素缓冲对象ebo。设置一个索引的数组去实现绘制三角形的一个顺序，这个缓冲对象是不一样的缓冲对象，意味着实际上可以同时绑定，而他的data实际上就是一个index.最后绘画的时候同样调用的函数变成了gldrawelements。


>>>>着色器
  是给gpu小单元执行的一个程序，不同着色器之间的交流只有输入和输出。当然，里面也有一些不需要我们定义的，已经定义好的变量类似gl_Position,这样的我们只要吧数据交给他们就好了，至于后面的传输通信好像都不是我们需要关心的。
  输入的数据是一定需要定义的，如果输出的数据要在另一个着色器中输入，那我们也需要进行定义。如果是预定义的数据，其实我们可以不太关心。
    只要输出变量和下一个着色器的输入变量一致，实际上我们就可以一直传递下去
   数据类型极其简单，就是向量的数据类型，默认是float的向量

  顶点着色器为了更好地管理接受的数据，需要对应的position ，可以理解为最开始传入数据的时候，我们配置的顶点属性（用来解释对应顶点的数据，同时绑定layout）要告诉着色器这个数据具体在哪，该如何解释。
 片段着色器的out也是我们自己定义的（按理不该这样设计的，除非还有别的着色器需要我去写）
   uniform 是全局变量（区别于in 和out）,如果没使用的话，会被自动移除。无需通过顶点着色器作为中介

     （这个也是最好在激活后再进行寻找）通过glgetuniformlocation（shaderprogram,"Ourcolor"）;获取对应的位置
  在激活对应的着色器程序之后，我们可以通过glUniform4f（因为c库是不支持函数的重载的） 重新给着色器中的uniform变量中赋值四个float
        通过实操表明，uniform 变量是要在该shader里面立即用到的。
     index 实际上就是location

>>>创建属于自己的着色器类（实现分类管理的重要思想）
      要用到的文件string fstring sstream iostream 
      结构其实还是比较简单的，就是内容比较多

  路径这一块，实际上都是基于工作目录的（一般目录结尾/）,但是这里vs默认的有点问题，所以需要自己改成projectdir/，而不是projectdir。
  ../ 返回上一级目录，（注意目录和文件是不一样的），./ 强调是当前目录下的。
  synx void 报错一般是少了一个逗号

  实操：如何利用路径去加载文件
  打开文件的时候要确定能够抛出异常
  利用c++ string ,ifstream ,stringstream.路径是const char* 利用数据ifstream这个类打开文件。然后将里面的缓冲字符载入到stringstream 中，关闭文件，将stringstream 里面的数据转化成str赋值给string。然后就得到了这个文件里面的数据cosnt char * 能够成功构建shader,

>>>纹理
  我们需要指定三角形的每个顶点对应的纹理部分，这样每个顶点就会关联对应的一个纹理坐标。纹理坐标左下角是0，0。右上角是1，1。
 如果设置的纹理坐标超出了标准的范围之内。有不同的处理方式（就是超出范围的纹理的样式应该是什么） 纹理坐标循环的设置（s,t,r，还能这样吗，设置不同坐标轴的循环方式） .利用glTexParameteri设置纹理的一个超出边界的一个循环的效果.如果是climb to border的话，实际上是fv 后缀，即一个float vector;
  纹理过滤的方式，（如果图片分辨率低的话，一般是要做双线性插值），GL NEAREST临近过滤（相当于是做了一遍锐化吗），GL LINER 线性过滤（一般我们都是选这个，因为要反走样）。glTexParameter* 设置放大和缩小的的过滤方式。
  多级渐远纹理（mipmap） ,无限去创造一个低一倍分辨率的图（直到一个像素），使其能够，glgeneratemipmap。在不同的多级渐远纹理级别时，同样可以利用不同的过滤方式去减少边界感。
  多级渐进纹理是在纹理被缩小的情况下采用的，而不是纹理被放大的情况下采用的
  
  stb_image.h（单文件图像加载库）

 实操：
  源文件可以实现预定义的功能
  注意索引是整数类型，如果改成float 会出现不会报错，但是还是无法绘画图像，新的出错点
        
 总结：好像不管是什么，都是先生成一个有对应id 值的数据类型，然后绑定这个数据类型（纹理的话还得在传输生成之前设置相应的环绕，重复和过滤的一个方式），然后传输（生成）数据，定义显卡解读数据的方式。 vao就是一种解读方式（包含一整个流程）
  所以，实际上的vao是不管纹理的，所以在绑定vao之外还得绑定以下对应的texture

  为什么源文件的里面放define 和预处理器放define是一致的：
         虽然是不同的阶段(一个是预处理阶段，一个是链接源文件阶段（解析引用的外部文件）)
     看了以下这个stb_image.h 文件的架构，确实是这样的，先全部声明好确保编译能够通过，后面解析引用和链接的阶段是差不多放在一起的（使用条件编译#ifdefine确保所有的定义都能在链接的时候找到）

数据类型：uniform sampler2D texture   采样器的变量（在glsl里面通过使用texture函数进行采样器对纹理坐标的采样（vec2类型），从而得到一个vec3（rgb））

一个纹理的坐标值通常被命名为纹理单元（讲的什么东西，就是类似于对应的id）
纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。（最多允许16个）
我们可以一次绑定多个纹理，激活对应的纹理单元（glactivetexture）,传入我们需要的纹理单元。GL_TEXTURE0默认总是被激活的

mix函数和texture 函数

  激活对应的纹理单元，绑定对应的纹理（纹理单元和纹理的绑定）
  通过gluniform1i 来绑定纹理单元和采样器（采样器和纹理单元的绑定）

 采样器是对纹理坐标进行采样的（对于不同的纹理图，我们自然会在程序中绑定不同的纹理图，通过不同的纹理图和纹理单元进行绑定，就可以做到任选纹理图进行绘制了（或者同时绘制，因为我们可以同时active 多个纹理单元（每个纹理单元绑定不同的图）），着色器和程序里面是两个是由关系的，采样器会设置成绑定好的对应的纹理单元，对不同纹理分别采样）

  作业：用snapler2d采样的时候，将纹理坐标（x,y比如对称，反转可以实现对相应纹理值既进行改变了）

》》》坐标系统
正常来讲，超出标准坐标范围的顶点都将不可见，五个不同的坐标系统
局部空间：物体空间(相对于局部原点的坐标，物体起始的坐标)
世界空间：相对于一个世界的固定点的坐标
观察空间：使得每个坐标都是从摄像机或是观察者的角度进行观察的

为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)
裁剪空间：投影到裁剪坐标，即一个标准的cubic

我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。

一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行

屏幕空间：由glviewport 决定的渲染范围的相应坐标上

将坐标从一个坐标系变换为另一个坐标系。几个重要的模型变换矩阵分别是mvp,

正交投影矩阵：
ortho

透视投影矩阵：
perspective

glposition 进行mvp变换就好了

》》》摄像机
 观察矩阵将所有的世界坐标变换为相对于摄像机位置与方向的观察坐标
如何定义一个相机：
世界空间的位置，

摄像机的方向（方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。）

指向摄像机的这个向量，然后叉乘向上的向量（换一下顺序，得到向上的向量）（摄像机向右或向上的向量）
格拉姆-施密特正交化

创建一个lookat 矩阵（三个参数，位置，目标(的位置)和向上量）

实现三角形的绕⚪的旋转，x=sin(glfwgetTime)*10=】

》》》设置摄像机的移动，
注意观看的的方向一般不能固定，要和摄像机的正方向绑定（而不是固定的世界位置）
》》》设置摄像机的旋转：
偏航角和俯仰

