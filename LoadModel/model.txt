rmdir dir（删除空的目录）
rm -r dir(删除非空的目录)

vs studio工具包nut确实好用，简直就是外部导入神器

wavefront的.obj格式，xml的collada 的文件格式
Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。
本质上是一个递归

将一个物体加载到Scene对象中，遍历节点，获取对应的Mesh对象（我们需要递归搜索每个节点的子节点），并处理每个Mesh对象来获取顶点数据、索引以及它的材质属性。最终的结果是一系列的网格数据，我们会将它们包含在一个Model对象中。

网格mesh 代表的是单个的可绘制的实体（可以看成是最小的一个可以绘制的单元）

一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）。

结构体的预处理的指令，offsetof (struct—type(name), member-name)


model 类的特点：
路径导入模型；
private:
mesh数据的容器
文件目录的存储
绘制的方式是绘制每个面

处理节点的函数
处理面的函数

如何loadmodel;
Assimp::Importer importer;
const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs)

加载模型，先将模型放置到一个场景中（if(!scene)）...
目标文件目录（不包括文件的名，只是到最后的文件的目录）



我们希望处理场景中的所有节点，所以我们将第一个节点（根节点）传入了递归的processNode函数。因为每个节点（可能）包含有多个子节点，我们希望首先处理参数中的节点，再继续处理该节点所有的子节点，以此类推。这正符合一个递归结构，所以我们将定义一个递归函数。递归函数在做一些处理之后，使用不同的参数递归调用这个函数自身，直到某个条件被满足停止递归。在我们的例子中退出条件(Exit Condition)是所有的节点都被处理完毕。 

processonode 根据索引递归的处理每个节点的面（每个节点有一系列面的索引）


